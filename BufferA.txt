vec3 wrapAround(in vec3 originalPos, in vec2 nearPos, in vec2 screen)
{
    vec3 pos = mod(originalPos, vec3(screen, 1.0));
    float midX = screen.x / 2.0;
    float midY = screen.y / 2.0;
    if (nearPos.x < midX && pos.x > midX) pos.x -= screen.x;
    if (nearPos.y < midY && pos.y > midY) pos.y -= screen.y;
    if (nearPos.x > midX && pos.x < midX) pos.x += screen.x;
    if (nearPos.y > midY && pos.y < midY) pos.y += screen.y;
    
    return pos; 
}



//have a seprate check (has an x and y of the mouse)
// if the mousex and y is not the same as the center update
// stop moving when they are equal
//if mous.xy is not == to center .xy
// then move the center closer to where the mouse is
// by doing that it will get to the mouse
vec4 checkAndUpdate(in sViewport vp, in vec4 center1, in vec4 mouse)
{
    const float INCREMENTOR = 0.9;
    vec2 diff = vp.uv - center1.xy;
    
    // x check
    if (mouse.x != diff.x)
    {
        center1 = vec4(center1.x + INCREMENTOR, center1.yzw);
    }


    // y check
    if (mouse.y != diff.y)
    {
        center1 = vec4(center1.y + INCREMENTOR, center1.xzw);
    }
    
    if (center1.x == diff.x && center1.y == diff.y)
    {
        return center1;
    }
    
}



void mainImage( out vec4 fragColor, in sCoord fragCoord )
{
    
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // ray
    sRay ray;
    
    // viewport info
    sViewport vp;
    
      // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    
    // worm
    wWorm worm;
    
    fragColor = vec4(wrapAround(worm.center1.xyz, fragColor.zw, vp.pixelCoord), 1.0);
}