// wrapAround: the function is suppose to wrape the worm accround itself according to
// its neeares center piece.
//		originalPos: the original positionof the worm
//		nearPos: the nearest postion to be wrapped arround
//		screen: the view/ resoultion of the screen
vec3 wrapAround(in vec3 originalPos, in vec2 nearPos, in vec2 screen)
{
    vec3 pos = mod(originalPos, vec3(screen, 1.0)); // finds the "%" of the worm's original postion
    float midX = screen.x / 2.0; // the middle x coord of the screen
    float midY = screen.y / 2.0; // the middle y coord of the screen
    if (nearPos.x < midX && pos.x > midX) pos.x -= screen.x; // when going down x coord
    if (nearPos.y < midY && pos.y > midY) pos.y -= screen.y; // when going down y coord
    if (nearPos.x > midX && pos.x < midX) pos.x += screen.x; // when going up x coord
    if (nearPos.y > midY && pos.y < midY) pos.y += screen.y; // when going up y coord
    
    return pos; // returns the postion
}

// checkAndUpdate: suppose to check and update the postion in small steps as if the worm was walking
//		vp: holds the viewport information
//		center1: the worm's center
//		mouse: the mouse's xyzw coords
vec4 checkAndUpdate(in sViewport vp, in vec4 center1, in vec4 mouse)
{
    const float INCREMENTOR = 1.0; // constant incrementor
    vec2 diff = vp.uv - center1.xy; // the difference in screen with the center of the worrm
    
    // x check
    if (mouse.x != diff.x)
    {
        // suppose to increment the center via steps
        center1 = vec4(center1.x + INCREMENTOR, center1.yzw); 
    }

    // y check
    if (mouse.y != diff.y)
    {
        // suppose to increment the center via steps
        center1 = vec4(center1.y + INCREMENTOR, center1.xzw);
    }
    
    // Returns the final location when and the movement of the worm
    if (center1.x == diff.x && center1.y == diff.y)
    {
        return center1; // the new center/ position
    }
}

void mainImage( out vec4 fragColor, in sCoord fragCoord )
{
    
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // ray
    sRay ray;
    
    // viewport info
    sViewport vp;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    
    // worm
    wWorm worm;
    vec3 wormCenter = vec3(worm.center1.x, worm.center1.y, worm.center1.z);
    
    // the output
    fragColor = vec4(wrapAround(wormCenter, fragColor.zw, vp.pixelCoord), 1.0);
}