#version 330 core

/*
	Title: Final Project Rain with Light[n]ing
	Instructor Name: Daniel Buckstein
	Authors: Andrew Barnett & Shakeem Brown
*/

layout (location = 0) out vec4 aPosition;
layout (location = 6) out vec4 rtFragColor;

// UTILITY UNIFORMS
uniform sampler2D tex0;
uniform vec4 mouseClick;
uniform vec2 resolution;
uniform float time;

// LIGHT UNIFORMS
uniform vec4 light_color; // red
uniform vec4 light_ambient; // red
uniform float intensity; // 15.0
uniform float flickering_speed; // 1.5
uniform float flickering_offset; // 50.0

// VARRYING
flat in vec4 colorPart;
smooth in vec2 vs_UV;

// lengthOfVector: the maginute of a vec3
//		vector3: the vector being applied
float lengthOfVector(in vec3 v3)
{
    // the formula for the magintude of a vector 3
    return ((v3.x * v3.x) + (v3.y * v3.y) + (v3.z * v3.z)) * 0.5;
}

vec3 dither(in vec2 vScreenPos)
{
    vec2 vector2 = vec2(171.0, 231.0);
    vec2 theTime = vec2(time);
    vec2 screenPos_time = vScreenPos.xy + theTime;
	vec3 vDither = vec3(dot(vector2, screenPos_time));
	vDither.rgb = fract(vDither.rgb / vec3(103.0, 71.0, 97.0)) - vec3(0.5, 0.5, 0.5);
	return ( vDither.rgb / 255.0 ) * 0.375;
}

vec4 calcLight(in vec2 uv, in vec4 image)
{
	// DEFINING SCREEN PROPERTIES
    vec2 resolutionInverse = 1.0 / resolution;
    float ratio = resolution.y * resolutionInverse.y;
    vec2 location = ratio * (resolutionInverse * gl_FragCoord.xy);
    
    // LIGHT PROPERTIES
    vec3 lightPos = aPosition.xyz;
    float light_radius = 128.0; // the radius of the light
    light_radius += sin(time * flickering_speed) * flickering_offset; // the flickering effect
    
    // the delta of the light image in relation to the uv and the screen (& texture later on)
    vec3 delta = vec3(location - uv, location.x);
    delta.x /= light_radius / resolution.x; // makes the light's delta.x fixed to the radius
    delta.y /= light_radius / resolution.y; // makes the light's delta.y fixed to the radius
    float fragDistoLight = lengthOfVector(delta); // The distance from the light to the image
    
    vec3 normal_light_color = light_color.rbg * light_color.a; // The normalzied light color
    vec3 normal_light_ambient = light_ambient.rgb * light_ambient.a; // the normalized light ambiance color
    float attenuation = intensity / (lightPos.x + (lightPos.y * fragDistoLight) +
                                     (lightPos.z * fragDistoLight * fragDistoLight)); // Calculates the attenuation of the light
	
    vec3 new_light = normal_light_ambient + normal_light_color * attenuation; // the new light after combining the privous calculations
    new_light = pow(new_light, light_color.xyz); // the new light raised to the color gray
    new_light += dither(uv); // using impossible's function to add to the new light
    
    // The final shading lampert shading
   return  vec4(vec3(image.r) * lightPos, image.a);
}

void main()
{ 
    vec2 uv = vs_UV;
    uv.y *= -1.0;
    
    vec4 theTexture = texture(tex0, uv);
	vec4 finalImage = vec4(theTexture.xyz, 1.0) * colorPart;
	
	if (mouseClick.z == 1.0)
	{
		//finalImage = calcLight(uv, finalImage);
	}
    
    rtFragColor = finalImage;
}
