#version 330 core

/*
	Title: Final Project Rain with Light[n]ing
	Instructor Name: Daniel Buckstein
	Authors: Andrew Barnett & Shakeem Brown
*/

layout (points) in;
layout (triangle_strip, max_vertices = 12) out;

// TRANSFORM UNIFORMS
uniform mat4 uProjMat, uViewMat, uModelMat;

// PARTICLE UNIFORMS
uniform vec4 particleGenPos;
uniform vec3 gravityGenVec, velocityGenMin, velocityGenRange;
uniform vec4 colorGen;
uniform float sizeGen;
uniform float lifeGenMin, lifeGenRange;
uniform float timePassed;
uniform int jNumToGen;
uniform vec3 randomSeed;
vec3 localSeed;

// VARRYINGS FROM VERTEX SHADER
in vec4 position[];
in vec3 velocity[];
in vec4 color[];
in float lifetime[];
in float size[];
in int j[];

// VARRYINGS SENT FURTHER
out vec4 aPosOut;
out vec3 aVelocityOut;
out vec4 aColorOut;
out float fLifeTimeOut;
out float fSizeOut;
out int jTypeOut;
smooth out vec2 vs_UV;
flat out vec4 colorPart;

// randNumRange: returns a random number from 0 to 1
float randNumRange()
{
	uint n = floatBitsToUint(localSeed.y * 214013.0 + localSeed.x * 2531011.0 + localSeed.z * 141251.0);
	n = n * (n * n * 15731u + 789221u);
	n = (n >> 9u) | 0x3F800000u;
	
	float fRes = 2.0 - uintBitsToFloat(n);
	localSeed = vec3(localSeed.x + 147158.0 * fRes, localSeed.y * fRes + 415161.0 * fRes, localSeed.z + 324154.0 * fRes);
	return fRes;
}

void particleGenerator(in int k)
{
	aPosOut.xyz = position[k].xyz;
	aVelocityOut = velocity[k]; 
	fSizeOut = size[k];
	
	if (j[k] != 0)
	{
		aPosOut.xyz += aVelocityOut * timePassed;
		vec4 vertPos = aPosOut;
		mat4 modelViewMatrix = uProjMat * uViewMat * uModelMat;
		
		colorPart = vec4(color[k].xyz, lifetime[k]);
		
		// LOWER LEFT CORNER
		vec2 llcPos = vertPos.xy + vec2(-0.5, -0.5) * fSizeOut;
		gl_Position = modelViewMatrix * vec4(llcPos, vertPos.zw);
		vs_UV = vec2(0.0, 0.0);
		EmitVertex();
		
		// UPPER LEFT CORNER
		vec2 ulcPos = vertPos.xy + vec2(-0.5, 0.5) * fSizeOut;
		gl_Position = modelViewMatrix * vec4(ulcPos, vertPos.zw);
		vs_UV = vec2(0.0, 1.0);
		EmitVertex();
		
		// LOWER RIGHT CORNER
		vec2 lrcPos = vertPos.xy + vec2(0.5, -0.5) * fSizeOut;
		gl_Position = modelViewMatrix * vec4(lrcPos, vertPos.zw);
		vs_UV = vec2(1.0, 0.0);
		EmitVertex();
		
		// UPPER RIGHT CORNER
		vec2 urcPos = vertPos.xy + vec2(0.5, 0.5) * fSizeOut;
		gl_Position = modelViewMatrix * vec4(urcPos, vertPos.zw);
		vs_UV = vec2(1.0, 1.0);
		EmitVertex();
		
		EndPrimitive();
	}
	
	if (j[k] != 0)
	{
		aVelocityOut += gravityGenVec * timePassed;
	}

	aColorOut = color[k];
	fLifeTimeOut = lifetime[k] - timePassed;
	fSizeOut = size[k];
	jTypeOut = j[k];
	vec3 randomVelocityRange = vec3(velocityGenRange.x * randNumRange(), velocityGenRange.y * randNumRange(), velocityGenRange.z * randNumRange());
	
	if (jTypeOut != 0)
	{
		EmitVertex();
		EndPrimitive();
		
		for (int i = 0; i < jNumToGen; i++)
		{
			aPosOut.xyz = particleGenPos.xyz;
			aVelocityOut = velocityGenMin + randomVelocityRange;
			aColorOut = colorGen;
			fLifeTimeOut = lifeGenMin + lifeGenRange * randNumRange();
			fSizeOut = sizeGen;
			jTypeOut = 1;
			EmitVertex();
			EndPrimitive();
		}
	}
	else if (fLifeTimeOut > 0.0)
	{
		EmitVertex();
		EndPrimitive();
	}
}

void main()
{
	particleGenerator(0);
	particleGenerator(1);
	particleGenerator(2);
}