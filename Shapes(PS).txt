#version 300 es
//#version 450

/*
	Title: Lab 8 Shader Pipelines
	Instructor Name: Daniel Buckstein
	Authors: Andrew Barnett & Shakeem Brown
*/

#ifdef GL_ES
precision highp float;
#endif // GL_ES

layout (location = 0) out vec4 rtFragColor;
layout(location = 1) out float visibility;

// VARYINGS
in vec4 vPosClip;
in vec4 objPos;
in vec4 norm;
in vec4 shadowCoord;

// UNIFORMS FOR LIGHT & FIGURE PROPERTIES
uniform mat4 uViewMat, uPerMat;
uniform vec3 objColor;
uniform float objShininess;
uniform vec3 viewPosition;
uniform vec3 lightPos;
uniform vec3 lightAmbient;
uniform vec3 lightDiffuse;
uniform vec3 lightSpecular;
uniform vec3 geoColor;
uniform sampler2D shadowMap;

// depthTest: used to test when a shadow needs to be drawn and where
// for perspective projection
vec3 depthTest()
{
    mat4 invViewMat = inverse(uViewMat); // inverse of view matrix
	vec3 wPoint = vec3(invViewMat * vec4(lightPos, 1.0)); // world's position in space
	vec3 lightSpacePoint = vec3(uPerMat * vec4(wPoint, 1.0)); // light's position in space
	lightSpacePoint = lightSpacePoint * 0.5 + 0.5; // NDC -> space: [-1, +1] -> [0, 1]
	float realDepth = lightSpacePoint.z; // defining the light space point's "z" for later use.
	return lightSpacePoint; // curently returns the light space point
}

// calcLight: caluculates light and its effect of the figures
vec4 calcLight()
{
   vec3 lightPos = normalize(lightPos - objPos.xyz); // calculates the light's Position
   vec3 viewVec = normalize(viewPosition.xyz - objPos.xyz); // calcultes the view vector
   vec3 refLightVec = reflect(-lightPos, norm.xyz);  // calculates the reflected light vector
 
   // Calculates the light's specular intensity
   vec3 specIntensity = pow(max(0.0, dot(viewVec,refLightVec)), objShininess) * lightSpecular;
   // Calculates the light's diffuse intensity
   vec3 diffIntensity = lightDiffuse * dot(viewVec,lightPos);
   
   float dis = distance(lightPos, objPos.xyz); // The distance between light position and object position
   // Calculates the attenuation
   float attenuation = 1.0 /(1.0 + 0.1*dis + 0.01*dis*dis);
   // The color changes being calculated based on the light with the figures
   vec3 color = ((diffIntensity + specIntensity)*attenuation) * visibility;
   color = (color + lightAmbient)*geoColor;

   return vec4(color, 1.0);
}

void main()
{
    float visibility = 1.0;
	vec4 shadowTex = texture(shadowMap, shadowCoord.xy );
	if (shadowTex.z  <  shadowCoord.z)
	{
	    visibility = 0.5;
	}
	
	rtFragColor = calcLight(); // outputs the light
	
    // Making sure every obj has a different hue
    rtFragColor += vec4(geoColor, 1.0);
    
}