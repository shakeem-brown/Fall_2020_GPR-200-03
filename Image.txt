// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
//  -> IMAGE TAB (final)
/*
	Authors: Andrew Barnett & Shakeem Brown
*/


vec3 drawSphere(in wWorm worm, in vec4 center1, in float radius, in sRay ray)
{
    //TEST
    vec3 dp; // the instance of the vec3 dotproduct called "dp"
    dp.xy = ray.direction.xy - worm.center1.xy; // intialazing the dotproduct with the xy of the ray
    											// direction and the sphere center
    float lSq = dot(dp.xy, dp.xy); // the length squared of the dot product
    float rSq = worm.radius * worm.radius; // the radius squared
    
        // INSIDE OF THE SPHERE
    if (lSq <= rSq)
    {
        dp.z = rSq - lSq; // setting the dotproduct of z to the radius square minus the length square
        vec3 position = worm.center1.xyz + vec3(dp.x, dp.y, sqrt(dp.z)); // the position of the sphere
        vec3 normal = vec3 (position - worm.center1.xyz) / worm.radius; // normalizing the sphere
        
        
        vec3 sphere_color = vec3(1.0, 0.0, 0.0);
        
        return sphere_color;
    }
    
    
}

vec4 getInput(in vec4 mouse, in sViewport screen, in sCoord fragCoord)
{
    vec2 pixelSizeInTextureSpace = 1.0 / iChannelResolution[0].xy;

    vec2 uv = fragCoord * pixelSizeInTextureSpace;
    
    vec2 mouse_input =  mouse.xy * pixelSizeInTextureSpace;
    if (mouse.z > 0.0) // checking if the mouse is clicked or not
    {
        return vec4(mouse_input, mouse.z , 1.0);
    }
    else // not clicked (stationary)
    {
        return vec4(mouse_input, mouse.z, 0.0);
    }
}

vec3 wormBuilder(in vec3 head, in vec3 segement1,in vec3 segement2,in vec3 segement3)
{
    vec3 buildWorm = head + segement1 + segement2 + segement3;
    
    return buildWorm;
}

vec3 drawWorm(in wWorm worm, in vec4 center1,
              in vec4 center2, in vec4 center3, in vec4 center,
              in float radius, in sRay ray,
              in vec4 mouse, in sViewport screen, in sCoord fragCoord)
{
    initWorm(worm, worm.center1, worm.center2, worm.center3, worm.center4, worm.radius);
    
    vec3 wormHead = drawSphere(worm, worm.center1, worm.radius, ray);
    float diameter = 2.0 * worm.radius;
    worm.center2 = vec4(diameter + worm.center1);
    
    vec3 segement1 = drawSphere(worm, worm.center2, worm.radius, ray);
    worm.center3 = vec4(diameter + worm.center2);
    
    vec3 segement2 = drawSphere(worm, worm.center3, worm.radius, ray);
    worm.center4 = vec4(diameter + worm.center3);
    
    vec3 segement3 = drawSphere(worm, worm.center4, worm.radius, ray);
    
    vec2 mouse_input = getInput(mouse, screen, fragCoord).xy, direction;
    float xDiff = mouse_input.x - wormHead.x;
    float yDiff = mouse_input.y - wormHead.y;
       
    // Defining movement of the worm
    if (abs(xDiff) > abs(yDiff)) // x case
    {
        if (xDiff > 0.0)
        {
            direction = vec2(2.0 * worm.radius, 0.0);
        }
        else
        {
            direction = vec2(-2.0 * worm.radius, 0.0);
        }
    }
    else // y calse
    {
        if (yDiff > 0.0)
        {
            direction = vec2(0.0, 2.0 * worm.radius); // (the (*) radius) causes the screen to change color
        }
        else
        {
            direction = vec2(0.0, -2.0 * worm.radius);
        }
    } 
    
    vec3 finalDirection = vec3(direction, 0.0);
    vec3 theWorm = wormBuilder(wormHead, segement1,segement2,segement3) + finalDirection;
    
    return theWorm;
}


vec4 createScene(in wWorm worm, in vec4 center1, in vec4 center2,
                 in vec4 center3, in vec4 center4,in float radius, in sRay ray,
              in vec4 mouse, in sViewport screen, in sCoord fragCoord)
{
    //THE WALLS
    
    vec3 dp;
    dp.xy = ray.direction.xy - worm.center1.xy;
    float lSq = dot(dp.xy, dp.xy);
    float rSq = worm.radius * worm.radius;
    
    // THE WORM
	if (lSq <= rSq)
    {
        return vec4(drawWorm(worm, center1, center2, center3, center4,
                             radius, ray, mouse, screen, fragCoord), 1.0);
    }
    
    //THE FLOOR
    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);
    return blue;
}













// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // ray
    sRay ray;
    
    // worm
    wWorm worm;
    worm.radius = 0.2; 
    worm.center1 = vec4(0.0, 0.0, -4.0, 1.0);
    worm.center2 = vec4(0.0, 0.0, -4.0, 1.0);
    worm.center3 = vec4(0.0, 0.0, -4.0, 1.0);
    worm.center4 = vec4(0.0, 0.0, -4.0, 1.0);
    
    // viewport info
    sViewport vp;
    
    vec2 pixelSizeInTextureSpace = 1.0 / iChannelResolution[0].xy;

    vec2 uv = fragCoord * pixelSizeInTextureSpace;
    
        // TESTING
    // set iChannel0 to 'Misc/Buffer A' and fetch sample
    fragColor = createScene(worm, worm.center1, worm.center2, worm.center3, worm.center4, worm.radius, ray,
              iMouse, vp, fragCoord);
}