// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
//  -> IMAGE TAB (final)
/*
	Authors: Andrew Barnett & Shakeem Brown
*/


vec3 drawSphere(in wWorm worm, in vec4 center, in float radius, in sRay ray)
{
    //TEST
    vec3 dp; // the instance of the vec3 dotproduct called "dp"
    dp.xy = ray.direction.xy - worm.center.xy; // intialazing the dotproduct with the xy of the ray
    											// direction and the sphere center
    float lSq = dot(dp.xy, dp.xy); // the length squared of the dot product
    float rSq = worm.radius * worm.radius; // the radius squared
    
        // INSIDE OF THE SPHERE
    if (lSq <= rSq)
    {
        dp.z = rSq - lSq; // setting the dotproduct of z to the radius square minus the length square
        vec3 position = worm.center.xyz + vec3(dp.x, dp.y, sqrt(dp.z)); // the position of the sphere
        vec3 normal = vec3 (position - worm.center.xyz) / worm.radius; // normalizing the sphere
        
        
        vec3 sphere_color = vec3(1.0, 0.0, 0.0);
        
        return sphere_color;
    }
    
    
}

vec4 getInput(in vec4 mouse, in sViewport screen, in sCoord fragCoord)
{
    vec2 pixelSizeInTextureSpace = 1.0 / iChannelResolution[0].xy;

    vec2 uv = fragCoord * pixelSizeInTextureSpace;
    
    vec2 mouse_input =  mouse.xy * pixelSizeInTextureSpace;
    if (mouse.z > 0.0) // checking if the mouse is clicked or not
    {
        return vec4(mouse_input, mouse.z , 1.0);
    }
    else // not clicked (stationary)
    {
        return vec4(mouse_input, mouse.z, 0.0);
    }
}

vec3 drawWorm(in wWorm worm, in vec4 center, in float radius, in sRay ray,
              in vec4 mouse, in sViewport screen, in sCoord fragCoord)
{
    initWorm(worm, worm.center, worm.radius);

    vec3 wormHead = drawSphere(worm, worm.center, worm.radius, ray);
    
    
    vec2 mouse_input = getInput(mouse, screen, fragCoord).xy, direction;
    float xDiff = mouse_input.x - wormHead.x;
    float yDiff = mouse_input.y - wormHead.y;
       
    // Defining movement of the worm
    if (abs(xDiff) > abs(yDiff)) // x case
    {
        if (xDiff > 0.0)
        {
            direction = vec2(2.0 * worm.radius, 0.0);
        }
        else
        {
            direction = vec2(-2.0 * worm.radius, 0.0);
        }
    }
    else // y calse
    {
        if (yDiff > 0.0)
        {
            direction = vec2(0.0, 2.0 * worm.radius); // (the (*) radius) causes the screen to change color
        }
        else
        {
            direction = vec2(0.0, -2.0 * worm.radius);
        }
    } 
    
    return vec3(direction, 1.0);
}


vec4 createScene(in wWorm worm, in vec4 center, in float radius, in sRay ray,
              in vec4 mouse, in sViewport screen, in sCoord fragCoord)
{

    return vec4(drawWorm(worm, center, radius, ray, mouse, screen, fragCoord), 1.0);
}













// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // ray
    sRay ray;
    
    // worm
    wWorm worm;
    worm.radius = 0.2; 
    worm.center = vec4(0.0, 0.0, -4.0, 1.0);
    
    // viewport info
    sViewport vp;
    
    vec2 pixelSizeInTextureSpace = 1.0 / iChannelResolution[0].xy;

    vec2 uv = fragCoord * pixelSizeInTextureSpace;
    
        // TESTING
    // set iChannel0 to 'Misc/Buffer A' and fetch sample
    fragColor = createScene(worm, worm.center, worm.radius, ray,
              iMouse, vp, fragCoord);
}