#version 300 es
//#version 450

/*
	Title: Lab 8 Shader Pipelines
	Instructor Name: Daniel Buckstein
	Authors: Andrew Barnett & Shakeem Brown
*/

//  SPHERE OBJECT-SPACE
layout (location = 0) in vec4 aPosition;
layout(location = 1) in vec3 aNormal;

// PLANE OBJECT SPACE
//layout (location = 1) in vec4 pPosition;

uniform mat4 uModelMat, uViewMat, uProjMat;

out vec4 vPosClip;

// calcDifIntensity: calculates the diffuse intensity
//		mPos: the object-space
//		vPos: the camera-space
//		intensity: the intensity of the light
//		lightCenter: the light's center
vec3 calcDifIntensity(vec4 mPos,
vec4 vPos, float intensity, vec3 lightCenter)
 {
 	vec3 lightPos = normalize(lightCenter - aPosition.xyz); // Calculates the light's position
	float difCoefficient = max(0.0, dot(aNormal, lightPos)); // calculates the diffues coefficent
	vec3 lightDis = vec3(lightCenter - 1.0);  // calculates the light's distance
	vec3 attenuation = 1.0 / (1.0 + (lightDis / intensity)
	 + (lightDis * lightDis) / (intensity * intensity)); // calculates the attenuation
    vec3 difIntensity = vec3(difCoefficient * attenuation);  // calculates the diffuse intensity
    return difIntensity; // returns the diffuse intnesity
 }
 
 // calcBlinnIntensity: calculates the Blinn intensity
//		mPos: the object-space
//		vPos: the camera-space
//		intensity: the intensity of the light
//		lightCenter: the light's center
float calcBlinnIntensity(vec4 mPos,
 vec4 vPos, vec3 lightCenter)
{
	float intensity = 1.0;
   vec3 lightPos = normalize(lightCenter - aPosition.xyz); // calculates the light's Position
   vec3 viewVec = normalize(vPos.xyz - mPos.xyz); // calcultes the view vector
   vec3 refLightVec = reflect(-(lightPos), aNormal);  // calculates the reflected light vector
   float specCoefficient = max(0.0, dot(viewVec, refLightVec)); // calculates the specular coefficent
   float highExpo = 8.0; // 2.0^3.0 simplified
   float specIntensity = pow(specCoefficient, highExpo); // calculates the specular intensity
   
   vec3 half_vector = normalize(lightPos + viewVec); // calculates half the vector
   float blinnCoefficient = dot(aNormal, half_vector); // calculates the blinn Coefficient
   float blinnHighExpo = (4.0 * highExpo); // calculates the blinn coefficient
   float blinnSpecIntensity = pow(blinnCoefficient, blinnHighExpo); // calculates the blinn specular intensity
   return blinnSpecIntensity; // returns the blinn specular intensity
}

// calcBlinnPhong: calculates the Blinn Phong lighting in one call
//		appliedColor: the color of the light
//		mPos: the object-space
//		vPos: the camera-space
//		intensity: the intensity of the light
//		lightCenter: the light's center
//		baseLightColor: the texture or the orignial color of the object
vec3 calcBlinnPhong(vec4 mPos, vec4 vPos, vec3 lightCenter)
 {
 	float intensity = 1.0;
 	vec3 whiteLight = vec3(1.0);
 	vec3 difIntensity = calcDifIntensity(mPos,
vPos, intensity, lightCenter); // Calls the diffuse intensity function
        
   float blinnSpecIntensity = calcBlinnIntensity(mPos,
 vPos, lightCenter); //Calls the blinn specular intensity function
   
   vec3 blinn_phong_color =  vec3(((difIntensity * whiteLight) 
   + (blinnSpecIntensity * whiteLight)) * whiteLight); // Calculation the blinn phong effect/color
   return blinn_phong_color; // Returns the blinn phong effect/color
 }

void main()
{
	vec4 pos_view = uModelMat * aPosition;
	
	// SPHERE POSITION PIPELINE
	gl_Position = uProjMat * uViewMat * uModelMat * aPosition;
	// w = 1 because the point is conditional depending if its orthographic
	// w = is equal to the distance to  the viewer
	
	// LIGHT PIPELINE
	mat3 lightViewMat = mat3(uViewMat); // View Space matrix
	
	//gl_Position = uProjMat * uViewMat * uModelMat * pPosition;
	
	// LIGHT CENTER
	vec3 lightCenter1 = vec3(10.0, 0.0, 10.0); // The light's world's space center
	vec3 lightCenter1_view = lightCenter1 * lightViewMat; // The light's view space center

	vec4 light1_view = vec4(calcBlinnPhong(aPosition, pos_view, 
	lightCenter1_view), 1.0); // The light's view space intensity
	vPosClip = gl_Position;
}
